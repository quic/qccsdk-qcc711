/*
 * Copyright (c) 2020-2021 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

/*-------------------------------------------------------------------------
 * Include Files
 *-----------------------------------------------------------------------*/
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "qapi_types.h"
#include "qapi_status.h"
#include "qapi_task.h"
#include "qapi_heap.h"
#include "qapi_m2mdma.h"

#include "qcli_pal.h"
#include "qcli.h"
#include <qcli_api.h>

#include "m2mdma_demo.h"
/*-------------------------------------------------------------------------
 * Preprocessor Definitions and Constants
 *-----------------------------------------------------------------------*/
#define M2MDMA_DBG
#ifdef M2MDMA_DBG
#define M2MDMA_PRINTF(...)     QCLI_Printf(QCLI_M2mdma_Handle, __VA_ARGS__)
#else
#define M2MDMA_PRINTF(x, ...)
#endif


#define M2MDMA_MAX_TRANSLEN 1024
typedef enum  {
    M2MDMA_SRC_SRAM,
    M2MDMA_SRC_RRAM
} M2MDMA_SRC_MODE;

typedef struct M2MDMA_CopyParam{
    qapi_M2MDMA_Chan_t chan;
    M2MDMA_SRC_MODE srcmode;
    uint8_t *src;
    const uint8_t *rsrc;
    uint8_t *dst;
    uint32_t translen;
} M2MDMA_CopyParam;


/*-------------------------------------------------------------------------
 * Type Declarations
 *-----------------------------------------------------------------------*/



/*-------------------------------------------------------------------------
 * Static & global Variable Declarations
 *-----------------------------------------------------------------------*/
 /*this data is stored in nvm*/
 static const uint8_t nvm_test_data[M2MDMA_MAX_TRANSLEN] = {
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,
0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,
0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,
0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,
0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,
0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,
0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,
0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,
0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,
0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,
0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,
0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,
0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,
0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,
0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x00,
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,
0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,
0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,
0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,
0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,
0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,
0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,
0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,
0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,
0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,
0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,
0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,
0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,
0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,
0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x00,
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,
0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,
0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,
0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,
0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,
0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,
0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,
0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,
0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,
0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,
0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,
0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,
0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,
0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,
0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x00,
0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,
0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,
0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,
0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,
0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,
0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,
0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,
0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,
0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,
0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,
0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,
0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,
0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,
0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,
0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x00,
 };
 QCLI_Group_Handle_t QCLI_M2mdma_Handle;  /* Handle for our QCLI Command Group. */
 static M2MDMA_CopyParam M2mCallbackCtx[2];
 qbool_t ChanBlocking[2] = {0};

 /*-------------------------------------------------------------------------
 * Function declaration
 *-----------------------------------------------------------------------*/
 static void cmd_M2mdma_TestCallback(uint32_t Status, void *CallbackCtx);

/* M2MDMA demo command functions. */
static QCLI_Command_Status_t cmd_M2MDMA_Open(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t cmd_M2MDMA_Copy(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t cmd_M2MDMA_Close(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

static void M2MDMA_CMD_Help(void);



const QCLI_Command_t M2MDMA_CMD_List[] =
{
    /* cmd_function    cmd_string  usage_string                    description */
    {cmd_M2MDMA_Open,  "Open",     "<chan num> <blocking> ",       "M2MDMA channel open"},
    {cmd_M2MDMA_Copy,  "Copy",     "<chan num> <source> <length>", "M2MDMA copy"},
    {cmd_M2MDMA_Close, "Close",    "<chan num> ",                  "M2MDMA channel close"}
};

const QCLI_Command_Group_t M2MDMA_CMD_Group =
{
    "M2MDMA",
    (sizeof(M2MDMA_CMD_List) / sizeof(M2MDMA_CMD_List[0])),
    M2MDMA_CMD_List
};


/*-------------------------------------------------------------------------
 * Function defination
 *-----------------------------------------------------------------------*/
void Initialize_M2MDMA_Demo(void)
{
    /* Attempt to reqister the Command Groups with the qcli framework.*/
    QCLI_M2mdma_Handle = QCLI_Register_Command_Group(NULL, &M2MDMA_CMD_Group);
    if(QCLI_M2mdma_Handle)
    {
        M2MDMA_PRINTF("M2MDMA Registered \n");
    }
}

static QCLI_Command_Status_t cmd_M2MDMA_Copy(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    qapi_M2MDMA_Chan_t chan;
    M2MDMA_SRC_MODE src_mode;
    uint32_t copylen;
    uint8_t *src = NULL;
    uint8_t *dst = NULL;
    const uint8_t *rsrc;
    uint32_t i;
    qbool_t verify_status = true;
    qapi_Status_t ret;
    QCLI_Command_Status_t Retval;

    if (Parameter_Count != 3 || Parameter_List == NULL)
    {
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }

    chan = (qapi_M2MDMA_Chan_t)Parameter_List[0].Integer_Value;
    if (chan < QAPI_M2MDMA_CHAN_SE2_E || chan > QAPI_M2MDMA_CHAN_SE3_E)
    {
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }

    copylen = Parameter_List[2].Integer_Value;
    if (copylen > M2MDMA_MAX_TRANSLEN) {
        M2MDMA_PRINTF("ERROR:M2M DMA transfer length shoud not exceed 1024 in demo\n");
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }
    if (copylen % 4) {
        M2MDMA_PRINTF("ERROR:M2M DMA transfer length is not multiple of 4 bytes\n");
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }

    src_mode = (M2MDMA_SRC_MODE)Parameter_List[1].Integer_Value;
    if (src_mode == M2MDMA_SRC_SRAM) {
        src = (uint8_t*)qapi_Malloc(copylen);
        if (!src) {
            ret = QAPI_ERR_NO_MEMORY;
            goto TestExit;
        }
        dst = (uint8_t*)qapi_Malloc(copylen);
        if (!dst) {
            ret = QAPI_ERR_NO_MEMORY;
            goto TestExit;
        }

        for (i = 0; i < copylen; i ++) {
            if (i%256 == 0)
                src[i] = 0;
            else
                src[i] = src[i-1] + 1;
        }
    } else if (src_mode == M2MDMA_SRC_RRAM) {
        rsrc = nvm_test_data;
        dst = (uint8_t*)qapi_Malloc(copylen);
        if (!dst)
        {
            M2MDMA_PRINTF("ERROR: no enough memory\n");
            return QCLI_STATUS_ERROR_E;
        }
    } else {
            M2MDMA_PRINTF("Data Source Error, Shoul be 0 or 1\n");
            M2MDMA_CMD_Help();
            return QCLI_STATUS_ERROR_E;
    }
    memset(dst, 0, copylen);

    if (ChanBlocking[chan-QAPI_M2MDMA_CHAN_SE2_E]) {
        if (src_mode == M2MDMA_SRC_SRAM) {
            ret = qapi_M2MDMA_Copy(chan, dst, src, copylen, NULL);
        } else if (src_mode == M2MDMA_SRC_RRAM) {
            ret = qapi_M2MDMA_Copy(chan, dst, rsrc, copylen, NULL);
        }
        if (ret != QAPI_OK) {
            M2MDMA_PRINTF("ERROR:M2M DMA block copy operation failed, ret %d\n", ret);
            ret = QCLI_STATUS_ERROR_E;
            goto TestExit;
        }
        /* Validate the DMA transfer */
        verify_status = true;
        for (i = 0; i < copylen; i++) {
            if (src_mode == M2MDMA_SRC_SRAM) {
                if (src[i] != dst[i]) {
                    verify_status = false;
                    break;
                }
            } else if (src_mode == M2MDMA_SRC_RRAM){
                if (rsrc[i] != dst[i]) {
                    verify_status = false;
                    break;
                }
            }
        }
        for (i = 0; i < copylen; i++) {
            M2MDMA_PRINTF("0x%02x,", dst[i]);
            if (i%16 ==0) {
                M2MDMA_PRINTF("\n");
            }
        }
        M2MDMA_PRINTF("\n");
        if (verify_status) {
            M2MDMA_PRINTF("M2M DMA block copy %d bytes succesfully\n", copylen);
            ret = QCLI_STATUS_SUCCESS_E;
        } else {
            M2MDMA_PRINTF("ERROR:M2M DMA block copy verify failed\n");
            ret = QCLI_STATUS_ERROR_E;
        }

    } else {
        M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E].chan = chan;
        M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E].srcmode = src_mode;
        M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E].dst = dst;

        M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E].translen = copylen;
        if (src_mode == M2MDMA_SRC_SRAM) {
            M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E].src = src;
            ret = qapi_M2MDMA_Copy(chan, dst, src, copylen, &M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E]);
        } else if (src_mode == M2MDMA_SRC_RRAM) {
            M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E].rsrc = rsrc;
            ret = qapi_M2MDMA_Copy(chan, dst, rsrc, copylen, &M2mCallbackCtx[chan-QAPI_M2MDMA_CHAN_SE2_E]);
        }
        if (ret != QAPI_OK) {
            M2MDMA_PRINTF("ERROR:M2M DMA none-block copy operation failed, ret %d\n", ret);
            ret = QCLI_STATUS_ERROR_E;
            goto TestExit;
        } else {
            return QCLI_STATUS_SUCCESS_E;
        }
    }

TestExit:
    if (src && (src_mode == M2MDMA_SRC_SRAM)) {
        qapi_Free(src);
        src = NULL;
     }
     if (dst) {
         qapi_Free(dst);
         dst = NULL;
     }

    if (ret == QAPI_OK)
    {
        Retval = QCLI_STATUS_SUCCESS_E;
    }
    else
    {
        Retval = QCLI_STATUS_ERROR_E;
    }

    return Retval;
}

static QCLI_Command_Status_t cmd_M2MDMA_Open(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    qapi_M2MDMA_Chan_t chan;
    qbool_t blocking;
    qapi_Status_t ret;

    if (Parameter_Count != 2 || Parameter_List == NULL)
    {
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }

    chan = (qapi_M2MDMA_Chan_t)Parameter_List[0].Integer_Value;
    if (chan < QAPI_M2MDMA_CHAN_SE2_E || chan > QAPI_M2MDMA_CHAN_SE3_E)
    {
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }

    blocking = Parameter_List[1].Integer_Value;
    if (blocking) {
        ret = qapi_M2MDMA_Chan_Open(chan, NULL);
    } else {
        ret = qapi_M2MDMA_Chan_Open(chan, cmd_M2mdma_TestCallback);
    }

    if (ret != QAPI_OK) {
        M2MDMA_PRINTF("ERROR:M2M DMA chan open fail, error %d\n", ret);
        return QCLI_STATUS_ERROR_E;
    } else {
        M2MDMA_PRINTF("M2M DMA chan open succesfully\n");
    }
    ChanBlocking[chan-QAPI_M2MDMA_CHAN_SE2_E] = blocking;
    return QCLI_STATUS_SUCCESS_E;
}

static QCLI_Command_Status_t cmd_M2MDMA_Close(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    qapi_M2MDMA_Chan_t chan;
    qapi_Status_t ret;

    if (Parameter_Count != 1 || Parameter_List == NULL)
    {
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }

    chan = (qapi_M2MDMA_Chan_t)Parameter_List[0].Integer_Value;
    if (chan < QAPI_M2MDMA_CHAN_SE2_E || chan > QAPI_M2MDMA_CHAN_SE3_E)
    {
        M2MDMA_CMD_Help();
        return QCLI_STATUS_ERROR_E;
    }

    ret = qapi_M2MDMA_Chan_Close(chan);

    if (ret != QAPI_OK) {
        M2MDMA_PRINTF("ERROR:M2M DMA chan close fail, error %d\n", ret);
        return QCLI_STATUS_ERROR_E;
    } else {
        M2MDMA_PRINTF("M2M DMA chan close succesfully\n", ret);
        return QCLI_STATUS_SUCCESS_E;
    }

}

static void M2MDMA_CMD_Help(void)
{
    M2MDMA_PRINTF("Open  <Chan Num> <Blocking>\n");
    M2MDMA_PRINTF("Copy  <Chan Num> <Source> <Length>\n");
    M2MDMA_PRINTF("Close <Chan Num>\n");

    M2MDMA_PRINTF("\n");
    M2MDMA_PRINTF("\tChan Num : 2 - Chan 2, 3 - Chan 3\n");
    M2MDMA_PRINTF("\tBlocking : 0 - None Blocking, 1 - Blocking\n");
    M2MDMA_PRINTF("\tSource   : 0 - Data from SRAM, 1 - Data form RRAM\n");
    M2MDMA_PRINTF("\tLength   : Copy Data Length, Multiply of 4\n");

    return;
}


static void cmd_M2mdma_TestCallback(uint32_t Status, void *CCtx)
{
    M2MDMA_CopyParam *UserParam = (M2MDMA_CopyParam*)CCtx;
    qbool_t verify_status;
    uint32_t i;

    if (Status != QAPI_OK)  {
        M2MDMA_PRINTF("ERROR:M2M DMA Callback copy operation failed, ret %d\n", Status);
        goto Out;
    }

    /* Validate the DMA transfer */
    verify_status = true;
    for (i = 0; i < UserParam->translen; i++) {
         if (UserParam->srcmode ==M2MDMA_SRC_SRAM) {
            if (UserParam->src[i] != UserParam->dst[i]) {
                verify_status = false;
                break;
            }
         } else if (UserParam->srcmode ==M2MDMA_SRC_RRAM) {
            if (UserParam->rsrc[i] != UserParam->dst[i]) {
                verify_status = false;
                break;
            }
         }
     }
     for (i = 0; i < UserParam->translen; i++) {
        M2MDMA_PRINTF("0x%02x,", UserParam->dst[i]);
        if (i%16 ==0) {
            M2MDMA_PRINTF("\n");
        }
     }
     M2MDMA_PRINTF("\n");
     if (verify_status) {
         M2MDMA_PRINTF("M2M DMA Callback copy %d bytes succesfully\n", UserParam->translen);
     } else {
         M2MDMA_PRINTF("ERROR:M2M DMA Callback copy verify failed\n");
     }

Out:
     if (UserParam->srcmode == M2MDMA_SRC_SRAM) {
         qapi_Free(UserParam->src);
      }
      qapi_Free(UserParam->dst);
}



